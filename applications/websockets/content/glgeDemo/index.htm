<html><head> 
 
 
<title>GLGE</title> 
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
 

<script type="text/javascript" src="../GLGE/glge-compiled-min.js"></script> 
<style>
body{background-color: #000;color: #fff;font-family:arial}
</style>
</head><body>

<div id="dump"></div>

<div>
<div style="width:900px;margin:auto;position:relative" id="container">
<canvas id="canvas" width="900" 
height="500"></canvas>
    <!--
<img src="images/glgelogo.png" alt="GLGElogo" style="position:absolute;top: 450px; left: 750px;" />
    -->
<img src="images/MOVES_logo.jpg" alt="GLGElogo" style="position:absolute;top: 450px; left: 750px;" />
<div id="framerate" style="position:absolute; left: 750px; top: 20px; background-color: #000; opacity: 0.5;height: 30px; width: 130px; border-radius: 5px;	-moz-border-radius5px;-webkit-border-radius:5px;border: 1px solid #fff;">
<div id="debug" style="padding: 5px"></div>
</div>
<!--
<div style="padding: 5px;position:absolute; left: 20px; top: 370px; background-color: #000; opacity: 0.5;height: 100px; width: 400px; border-radius: 5px;	-moz-border-radius5px;-webkit-border-radius:5px;border: 1px solid #fff;">
<h2 style="margin:0;padding:0;padding-bottom: 5px;font-size: 20px">Text Rendering</h2>
<p style="margin:0;padding:0;padding-bottom: 5px;">Use mode and WASD key to move. Enter text to render:</p>
<p style="margin:0;padding:0;padding-bottom: 5px;"><input type="text" onkeydown="event.stopPropagation();" value="A man (billboard text)" style="border:1px solid #888;width: 100%" onkeyup="mantext.setText(this.value);" /></p>
</div>
-->
</div>

</div>


<div id="debug2"></div>
<script type="text/javascript">

//var moveThisMesh;
var websocket;

// Port must match what is specified on the server side, and the end part must
// match what we registered as the servlet handler
var websocketUri = "ws://localhost:8081/nve"

function writeToScreen(str)
{
  console.log(str);
}

// Initialize the web socket, and define various methods that are called
// on events such as an open, close, and, most importantly, a message.
function initializeWebsocket()
{
  // uri, and the protocl at that uri. We can also use subprotocols, for example versions, with something like "nve/v2"
  // 
  // Note that we have to worry about Firefox brain damage; for who knows what reason they decicded
  // to change the name to "Mozwebsocket" instead of "websocket". Gah.
  if(window.WebSocket)
    websocket = new WebSocket(websocketUri, "nve");
   else if (window.MozWebSocket)
       websocket = new MozWebSocket(websocketUri, "nve");
   else
   {
           writeToScreen("Websockets not supported in this browser");
           return;
   }
  
  websocket.onopen = function(evt) { onOpen(evt) };
  websocket.onclose = function(evt) { onClose(evt) };
  websocket.onmessage = function(evt) { onMessage(evt) };
  websocket.onerror = function(evt) { onError(evt) };
}

// Sends a text message to the server
function sendMessageToServer(message)
{
    writeToScreen("SENT: " + message); 
    websocket.send(message);
}


// Callback called on the open event, when the websocket establishes a connection
function onOpen(evt)
{
  writeToScreen("CONNECTED");
  writeToScreen("   websocket to " + websocketUri + " opened");
}

// Callback called when the websocket is closed
function onClose(evt)
{
    writeToScreen("DISCONNECTED");
    writeToScreen("   websocket to " + websocketUri + " closed");
}

// Called when we receive a message from the server
function onMessage(evt)
 {
    writeToScreen('MESSAGE FROM SERVER: ' + evt.data);

    // Input text is in JSON format. Convert it to a javascript object
    var updateObject = eval('(' + evt.data + ')');
    writeToScreen('converted to javascript object');
    mantext.setText("(" + updateObject.entityLocation.x +", " + updateObject.entityLocation.y + ", " + updateObject.entityLocation.z + ")");
    //guyAvatar.setLocX(updateObject.entityLocation.x);
    //guyAvatar.setLocZ(10);
    //guyAvatar.setDRotX(1.57);
    //guyAvatar.setDRotY(1.57);
    //guyAvatar.setDRotZ(1.57);
    //guyAvatar.setRotX(1.57);
    //guyAvatar.setRotY(1.57);
    //guyAvatar.setRotZ(1.57);
    
    teapot.setLocX(updateObject.entityLocation.x);
    teapot.setRotZ(updateObject.entityOrientation.psi);
    
    
    //moveThisMesh.position.set(updateObject.entityLocation.x,updateObject.entityLocation.y,updateObject.entityLocation.z);
 }
 
 // Called when we have some sort of error
 function onError(evt)
  {
    writeToScreen('<span style="color: red;">ERROR:</span> ' + evt.data);
  }

    
var mantext;
var guyAvatar;
var teapot;

var doc = new GLGE.Document();
doc.onLoad=function(){

initializeWebsocket();

mantext=doc.getElement("text1");
guyAvatar=doc.getElement("guy");
teapot=doc.getElement("teapotobject");


//create the renderer
var gameRenderer=new GLGE.Renderer(document.getElementById('canvas'));
gameScene=new GLGE.Scene();
gameScene=doc.getElement("mainscene");
gameRenderer.setScene(gameScene);

var mouse=new GLGE.MouseInput(document.getElementById('canvas'));
var keys=new GLGE.KeyInput();
var mouseovercanvas;
var hoverobj;


function mouselook(){
	if(mouseovercanvas){
		var mousepos=mouse.getMousePosition();
		mousepos.x=mousepos.x-document.getElementById("container").offsetLeft;
		mousepos.y=mousepos.y-document.getElementById("container").offsetTop;
		var camera=gameScene.camera;
		camerarot=camera.getRotation();
		inc=(mousepos.y-(document.getElementById('canvas').offsetHeight/2))/500;
		var trans=GLGE.mulMat4Vec4(camera.getRotMatrix(),[0,0,-1,1]);
		var mag=Math.pow(Math.pow(trans[0],2)+Math.pow(trans[1],2),0.5);
		trans[0]=trans[0]/mag;
		trans[1]=trans[1]/mag;
		camera.setRotX(1.56-trans[1]*inc);
		camera.setRotZ(-trans[0]*inc);
		var width=document.getElementById('canvas').offsetWidth;
		if(mousepos.x<width*0.3){
			var turn=Math.pow((mousepos.x-width*0.3)/(width*0.3),2)*0.005*(now-lasttime);
			camera.setRotY(camerarot.y+turn);
		}
		if(mousepos.x>width*0.7){
			var turn=Math.pow((mousepos.x-width*0.7)/(width*0.3),2)*0.005*(now-lasttime);
			camera.setRotY(camerarot.y-turn);
		}
	}
}

function checkkeys(){
	var camera=gameScene.camera;
	camerapos=camera.getPosition();
	camerarot=camera.getRotation();
	var mat=camera.getRotMatrix();
	var trans=GLGE.mulMat4Vec4(mat,[0,0,-1,1]);
	var mag=Math.pow(Math.pow(trans[0],2)+Math.pow(trans[1],2),0.5);
	trans[0]=trans[0]/mag;
	trans[1]=trans[1]/mag;
	var yinc=0;
	var xinc=0;
	if(keys.isKeyPressed(GLGE.KI_W)) {yinc=yinc+parseFloat(trans[1]);xinc=xinc+parseFloat(trans[0]);}
	if(keys.isKeyPressed(GLGE.KI_S)) {yinc=yinc-parseFloat(trans[1]);xinc=xinc-parseFloat(trans[0]);}
	if(keys.isKeyPressed(GLGE.KI_A)) {yinc=yinc+parseFloat(trans[0]);xinc=xinc-parseFloat(trans[1]);}
	if(keys.isKeyPressed(GLGE.KI_D)) {yinc=yinc-parseFloat(trans[0]);xinc=xinc+parseFloat(trans[1]);}
	if(keys.isKeyPressed(GLGE.KI_LEFT_ARROW)) {camera.setRotZ(0.5);}
	if(levelmap.getHeightAt(camerapos.x+xinc,camerapos.y)>30) xinc=0;
	if(levelmap.getHeightAt(camerapos.x,camerapos.y+yinc)>30) yinc=0;
	if(levelmap.getHeightAt(camerapos.x+xinc,camerapos.y+yinc)>30){yinc=0;xinc=0;}
		else{
		camera.setLocZ(levelmap.getHeightAt(camerapos.x+xinc,camerapos.y+yinc)+8);
		}
	if(xinc!=0 || yinc!=0){
		camera.setLocY(camerapos.y+yinc*0.05*(now-lasttime));camera.setLocX(camerapos.x+xinc*0.05*(now-lasttime));
	}
}


levelmap=new GLGE.HeightMap("images/map.png",120,120,-50,50,-50,50,0,50);


var lasttime=0;
var frameratebuffer=60;
start=parseInt(new Date().getTime());
var now;
function render(){
    now=parseInt(new Date().getTime());
	    frameratebuffer=Math.round(((frameratebuffer*9)+1000/(now-lasttime))/10);
	    document.getElementById("debug").innerHTML="Frame Rate:"+frameratebuffer;
    mouselook();
   checkkeys();
   gameRenderer.render();
   lasttime=now;
}
setInterval(render,1);
var inc=0.2;
document.getElementById("canvas").onmouseover=function(e){mouseovercanvas=true;}
document.getElementById("canvas").onmouseout=function(e){mouseovercanvas=false;}
}
doc.load("level.xml");
</script>

</body></html>